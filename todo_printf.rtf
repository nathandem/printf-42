{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww9360\viewh16580\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs28 \cf0 Questions :\
- peut-on arreter de print si une directive n'est pas valide ?\
	ex: printf("%# !s\\n");  printf("%-5.5\\n");   printf("!s");\
  ou faut-il skip les morceaux non valides et print ce qui est valide apres ?
\i \
For now, ignore the invalid part and resume printing afterwards.
\i0 \
\
- Retourner nb charact\'e8res affich\'e9s ?\

\i Not difficult, just return the counter `i` of the ft_printf function.
\i0 \
\
\
- Can the `0` flag be anywhere in the flag area? Not just before the min width field?\

\i I think yes, but is it?
\i0 \
\
\
\
\
\
\
\
\
Order of things:\
- find out how to deal with the different flags and make tests for this. All in isolation mode (one directive at the time), like I did for the parsing.\
- then, create the parsing system with stdarg, make some test with it for simple element (not integrate with the parser and the handlers)\
- lastly integrate, the directive parser and the handlers with the stdarg machine\
\
\
\
\
\
\
\
\
Points techniques\
\
1) nombre d'args non definis/connus \'e0 l'avance => 
\b fonction variadique (stdarg)
\b0 \
https://fr.wikipedia.org/wiki/Fonction_variadique\
https://en.wikipedia.org/wiki/Stdarg.h\
\
2) plein de formats et d'operations\
=> parser et handlers\
\
3) gros dispatcher, bonne structure\
- Pour faire le dispatcher, utiliser une grosse structure, contenant des pointeurs sur fonctions comme dans l'exo de piscine d10/ex09 (ex06 dans mon cas) & looper sur ce tableau\
\
3 et 4)\
=> tableau de structures\
Du genre:\
\
typedef struct	s_flags\
\{\
	char *flag;\
	<signature of the function> // 
\i sth in void* to fit every possibilities?
\i0 \
\}			t_flags;\
\
Note:\
- declaration d'un pointeur sur fonction, depend bcp du nb + types des parametres et du type de sortie\
void	(*fc_ptr)(type1, type2);\
- assignation\
fc_ptr = &function_name;\
- utilisation\
*fc_ptr(arg1, arg2);\
\
\
\
Note sur stdarg:\
Promotion/conversion/cast de types:\
char -> int (4 bytes)\
short (2 bytes) -> int\
float (4 bytes) -> double (8 bytes)\
\pard\pardeftab720\sl300\partightenfactor0
\cf0 \
src: https://www.geeksforgeeks.org/data-types-in-c/\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\
\

\b Compilation steps for printf_test file\

\b0 - Compile libftprintf.a\
1) prepare the object files making the lib (no need for a the -L and -l because it's not a main, just a lib)\
clang -Wall -Wextra -Werror -I src/libft -I src -o src/ft_printf.o -c src/ft_printf.c\
2) link the object files into a lib\
ar -rc src/libftprintf.a src/ft_printf.o\
\
- Use the library with the file\
clang -Wall -Wextra -Werror -I src/libft -I src -Lsrc/libft -lft  -Lsrc -lftprintf -o tests/basic_test tests/basic_test.c\
(we can optionally turn the c test file into an object before using it for compilation)\
\
\
\

\b Compilation command for the directive_parser
\b0 \
clang -I ../src/libft -I ../src -L../src/libft -lft ../src/directive_parsers.c test_helpers.c  directive_parser_test.c && ./a.out\
\
\
\
\
La string qui contient les % est appell\'e9e "format string". Elle contient des characteres normaux copi\'e9s normalement vers la sortie, des directives qui utilisent un ou plusieurs des arguments qui suivent cette string.\
Le type du/des arguments fourni doit correspondre \'e0 ce que la fonction de conversion attend (
\i after type promotion?
\i0 ).\
\
Liste des operateurs pouvant apparaitre apres % qu'il faut que l'on prenne en compte (dans leur ordre d'apparition):\
\
A) les 
\b flags
\b0  suivants :\
`#` differentes regles suivant la conversion qui suit, mais globalement il s'agit de conserver les 0\
`0` zero padding\
`-` negative field width flag\
`+` mettre un `+` devant un nb produit par une "signed conversion"\
` ` leave a blank before a positive nb produced by a signed conversion\
\
B) optional decimal digit string specifying a 
\b minimum field width
\b0 . Si la valeur convertie fait moins que cette valeur, ajouter des espaces sur la gauche (ou la droite si utilise le flag `-` ?)\
\
C) optional 
\b precision
\b0 , in the form of a . followed by an optional digit string. If no digit string, some defaults depending on the conversion flag provided\
\

\b attention \'e0 la diff\'e9rence \ul width\ulnone  et \ul precision\ulnone  > pour les chiffres et le reste. printf d'un gars en correction dead \'e0 cause de \'e7a.
\b0 \
\
D) 
\b Size
\b0 \
h\
hh\
l\
ll\
-> different comportement suivant la conversion de type fournie\
\
G) flag de 
\b conversion
\b0 \
`
\b c
\b0 ` un int est converti en unsigned char, le resultat est affich\'e9\
`
\b s
\b0 ` un char * est copi\'e9/affich\'e9\
`
\b p
\b0 ` void * affich\'e9 en hexadecimal\
\
`diouxX` avec les flags hh, h, l, ll\
=> int (or appropriate variant, cad ce que les flags de size donnent) convertit en \
	signed decimal (d and i - 2 letters here is useless, but included anyway for symetry with scanf) => signed decimal = signed int\
	unsigned octal (o) => unsigned int en base 8 ?\
	unsigned decimal (u) => unsigned int ?\
	unsigned hexadecimal (x and X) => unsigned int?\
		note: for x, `abcdef` are used; for x, `ABCDEF` are used for the letters\
\
\

\b f
\b0  takes a double argument, which gets rounded and converted to decimal notation (`xx.xx`). Avec des variations pour le nb de chiffres apres le `.` suivant la specification de longeur\
flags de longeur:\
l  double\
L  long double\
\
\
\

\b => pour les cas ind\'e9finis, faire en fonction de ce qui est le plus simple et le plus coh\'e9rent
\b0 \
\
\
Attention \'e0 la gestion de l'unicode. Optionnel\
\

\i Les caracteres speciaux sont g\'e9r\'e9s par write :)
\i0 \
\
Concernant les cas ind\'e9finis, il semblerait que la moulinette ne les teste pas.\
src:\
https://forum.intra.42.fr/topics/622/messages/last (dernier message)\
+ slack #ft_printf recherche avec "undefined"\
\
Des tests en python:\
https://forum.intra.42.fr/topics/18453/messages/last}